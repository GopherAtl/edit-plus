local selectedTextColor, selectedBGColor=colors.black,colors.white
local defaultTextColor, defaultBGColor=colors.white,colors.black


local function setColors(fg,bg)
  term.setTextColor(fg)
  term.setBackgroundColor(bg)
end

function padString(str,width,side)
  side=side and side:lower() or "right"
  if #str>width then
    --trim instead
    if side=="center" then
      local trim=(#str-width)/2
      str=str:sub(math.floor(trim)+1,#str-math.ceil(trim))
    elseif side=="left" then
      str=str:sub(#str-width+1)
    else
      str=str:sub(1,width)
    end
    return str
  end

  if side=="center" then
    local pad=(width-#str)/2
    str=(" "):rep(math.ceil(pad))..str..(" "):rep(math.floor(pad))
  elseif side=="left" then
    str=(" "):rep(width-#str)..str
  else
    str=str..(" "):rep(width-#str)
  end
  return str
end



--base gui zone
do
  local class_guielement = {
      --defaults
      FG=colors.white,
      BG=colors.black,
      focusFG=colors.white,
      focusBG=colors.black,
      selectedFG=colors.black,
      selectedBG=colors.white,
    }
  local class_guielement_meta = { __index=class_guielement }

  function class_guielement:isDirty()
    return self.dirty
  end

  function class_guielement:handleEvent(e)
  end

  function class_guielement:giveFocus()
    if self.canTakeFocus then
      self.hasFocus=true
      self.dirty=true
      return true
    end
  end

  function class_guielement:loseFocus()
    if self.hasFocus then
      self.hasFocus=false
      self.dirty=true
    end
  end

  function class_guielement:show()
    if not self.visible then
      self.visible=true
      self.dirty=true
    end
  end

  function class_guielement:hide()
    if self.visible then
      self.visible=false
    end
  end

  function class_guielement:doCursor()
    term.setCursorBlink(false)
  end

  function class_guielement:doHandler(name,...)
    local h=self[name]
    if type(h)=="function" then
      h(self,...)
    end
    --todo: implement event style handlers later
  end

  function subclassGuiElement(class)
    if class~=class_guimetatable then
      setmetatable(class,class_guielement_meta)
    end
  end

end

--label zone
do
  local class_label = {

    }
  local class_label_meta = { __index=class_label }
  subclassGuiElement(class_label)

  function class_label:draw()
    if self.colorInvert then
      setColors(self.BG,self.FG)
    else
      setColors(self.FG,self.BG)
    end
    term.setCursorPos(self.x,self.y)
    term.write(padString(self.text,self.width,self.textAlign))
    self.dirty=false
  end


  function newLabel(x,y,w,text,textAlign,invertColors)
    if type(textAlign)=="string" then
      textAlign=textAlign:lower()
    end
    if textAlign~="left" and textAlign~="right" and textAlign~="center" then
      textAlign="left"
    end
    local label={
        x=x,
        y=y,
        width=w,
        height=1,
        colorInvert=invertColors,
        text=text or "label",
        dirty=true,
        textAlign=textAlign,
        visible=true,
      }
    setmetatable(label,class_label_meta)
    return label
  end
end

--hline
do
  local class_hline = { }
  local class_hline_meta = { __index=class_hline }
  subclassGuiElement(class_hline)

  function class_hline:draw()
    setColors(self.FG,self.FG)
    term.setCursorPos(self.x,self.y)
    term.write((" "):rep(self.width))
    self.dirty=false
  end

  function newHLine(x,y,w,color)
    local label={
        x=x,
        y=y,
        width=w,
        height=1,
        BG=color,
        dirty=true,
        visible=true,
      }
    setmetatable(label,class_hline_meta)
    return label
  end
end


--vline
do
  local class_vline = { }
  local class_vline_meta = { __index=class_vline }
  subclassGuiElement(class_vline)

  function class_vline:draw()
    setColors(self.FG,self.BG)
    for y=self.y,self.y+self.height-1 do
      term.setCursorPos(self.x,y)
      term.write((" "):rep(self.width))
    end
    self.dirty=false
  end

  function newVLine(x,y,h,color)
    local label={
        x=x,
        y=y,
        width=1,
        height=h,
        BG=color,
        dirty=true,
        visible=true,
      }
    setmetatable(label,class_vline_meta)
    return label
  end
end


--button zone
do
  local class_button = { }
  local class_button_meta = { __index=class_button }
  subclassGuiElement(class_button)

  function class_button:draw()
    term.setCursorPos(self.x,self.y)
    if self.hasFocus==self.colorInvert then
      setColors(self.FG,self.BG)
      term.write("["..padString(self.text,self.width-2,"center").."]")
    else
      setColors(self.BG,self.FG)
      term.write(" "..padString(self.text,self.width-2,"center").." ")
    end
  end

  function class_button:doCursor()
    if self.colorInvert then
      setColors(self.BG,self.FG)
    else
      setColors(self.FG,self.BG)
    end
    term.setCursorPos(self.x+1,self.y)
    term.setCursorBlink(true)
  end

  function class_button:handleEvent(e)
    if e[1]=="key" then
      if e[2]==keys.enter then
        self:doHandler("onClick",e[2],e[3],e[4])
        handled=true
      end
    elseif e[1]=="mouse_click" then
      if e[2]==1 then
        self:doHandler("onClick",e[2],e[3],e[4])
        handled=true
      end
    end
  end

  function newButton(x,y,w,text,invertColors)
    local button={
        x=x,
        y=y,
        width=w,
        height=1,
        colorInvert=invertColors,
        text=text or "button",
        dirty=true,
        canTakeFocus=true,
        visible=true,
      }
    setmetatable(button,class_button_meta)
    return button
  end
end

--text field zone
--dialog zone
do
  local class_textfield = { }
  local class_textfield_meta = { __index=class_textfield }
  subclassGuiElement(class_textfield)

  function class_textfield:draw()
    term.setCursorPos(self.x,self.y)
    setColors(self.FG,self.BG)
    local visStr=self.text:sub(self.scrollPos)

    if self.hasFocus then
      term.write("["..padString(visStr,self.width-2).."]")
    else
      term.write(" "..padString(visStr,self.width-2).." ")
    end
  end

  function class_textfield:doCursor()
    setColors(self.FG,self.BG)
    term.setCursorPos(self.x+self.cursorPos-self.scrollPos+1,self.y)
    term.setCursorBlink(true)
  end

  function class_textfield:handleEvent(e)
    local handled=false
    local prevCurPos=self.cursorPos
    if e[1]=="key" then
      if e[2]==keys.left then
        self.cursorPos=math.max(1,self.cursorPos-1)
        handled=true
      elseif e[2]==keys.right then
        self.cursorPos=math.min(#self.text+1,self.cursorPos+1)
        handled=true
      elseif e[2]==keys.home then
        self.cursorPos=1
        handled=true
      elseif e[2]==keys["end"] then
        self.cursorPos=#self.text+1
        handled=true
      elseif e[2]==keys.backspace then
        self.text=self.text:sub(1,self.cursorPos-2)..self.text:sub(self.cursorPos)
        self.cursorPos=math.max(1,self.cursorPos-1)
        self.dirty=true
        handled=true
      elseif e[2]==keys.delete then
        label=label:sub(1,self.cursorPos-1)..label:sub(self.cursorPos+1)
        self.dirty=true
        handled=true
      end
    elseif e[1]=="char" then
      --insert to text
      self.text=self.text:sub(1,self.cursorPos-1)..e[2]..self.text:sub(self.cursorPos)
      self.cursorPos=self.cursorPos+1
      self.dirty=true

      handled=true
    elseif e[1]=="mouse_click" and e[2]==1 then
      self.cursorPos=e[3]-self.x+self.scrollPos-1
      handled=true
    elseif e[1]=="mouse_scroll" then
      self.cursorPos=math.max(1,math.min(#self.text-self.scrollPos+2,self.cursorPos+e[2]))
      handled=true
    end

    if prevCurPos~=self.cursorPos then
      if self.cursorPos<self.scrollPos then
        self.scrollPos=self.cursorPos
        self.dirty=true
      elseif self.cursorPos>self.scrollPos+self.width-1 then
        self.scrollPos=self.cursorPos-self.width+1
        self.dirty=true
      end
    end

    return handled
  end

  function class_textfield:setText(text)
    self.text=text
    self.cursorPos=#text+1
    self.scrollPos=math.max(1,#text-self.width)
    self.dirty=true
  end

  function newTextField(x,y,w)
    local field={
        x=x,
        y=y,
        width=w,
        height=1,
        text="",
        dirty=true,
        canTakeFocus=true,
        cursorPos=1,
        scrollPos=1,
        visible=true,
      }

    setmetatable(field,class_textfield_meta)
    return field
  end

end

--dialog zone
do
  local class_dialog = { }
  local class_dialog_meta = { __index=class_dialog }
  subclassGuiElement(class_dialog)

  function class_dialog:draw()
    for i=1,#self.children do
      if self.children[i].dirty then
        self.children[i]:draw()
      end
    end
    self.dirty=false
  end

  function class_dialog:isDirty()
    if self.dirty then
      return true
    end
    for i=1,#self.children do
      if self.children[i].dirty then
        return true
      end
    end
  end


  function class_dialog:doCursor()
    if self.hasFocus and self.focusChild then
      self.children[self.focusChild]:doCursor()
    else
      term.setCursorBlink(false)
    end
  end

  function class_dialog:handleEvent(event)
    local handled=false
    if event[1]:sub(1,6)=="mouse_" then
      local mx,my=event[3],event[4]
      for i=1,#self.children do
        local child=self.children[i]
        if mx>=child.x and mx<child.x+child.width and
           my>=child.y and my<child.y+child.height then
          if self.focusChild~=i and child.canTakeFocus then
            self.children[self.focusChild]:loseFocus()
            self.focusChild=i
            child:giveFocus()
          end
          if child:handleEvent(event) then
            handled=true
            break
          end
        end
      end
    elseif event[1]=="key" or event[1]=="char" then
      if event[2]==keys.leftCtrl then
        --focus to my menu?
        --handled=true
      elseif event[2]==keys.tab then
        --give focused child a chance
        if self.focusChild then
          handled=self.children[self.focusChild]:handleEvent(event)
        end
        if not handled and self.focusChild then
          self.children[self.focusChild]:loseFocus()
          repeat
            self.focusChild=self.focusChild%#self.children+1
          until self.children[self.focusChild]:giveFocus()
          handled=true
        end
      elseif self.focusChild then
        handled=self.children[self.focusChild]:handleEvent(event)
      end
    else
      --anything not key or mouse related, give 'em all a stab at
      for i=1,#self.children do
        if self.children[i]:handleEvent(event) then
          break
        end
      end
    end
    return handled
  end

  function class_dialog:addElement(child)
    self.children[#self.children+1]=child
    if self.focusChild==nil and child.canTakeFocus then
      self.focusChild=#self.children
      child.parent=self
    end
  end

  function class_dialog:giveFocus()
    self.hasFocus=true
    self.dirty=true
    if self.focusChild==nil then
      self.focusChild=0
      repeat
        self.focusChild=self.focusChild+1
      until self.focusChild>#self.children or self.children[self.focusChild]:giveFocus()
      if self.focusChild>#self.children then
        self.focusChild=nil
      end
    end
  end

  function class_dialog:show()
    if not self.visible then
      self.visible=true
      self.dirty=true
      for i=1,#self.children do
        if self.children[i].visible then
          self.children[i].dirty=true
        end
      end
    end
  end

  function class_dialog:runModal()
    self:show()
    self:giveFocus()
    while self.visible do
      if self:isDirty() then
        self:draw()
      end
      self:doCursor()
      local e={os.pullEvent()}
      self:handleEvent(e)
    end
    self:hide()
  end

  function newDialog(x,y,w,h)
    local dialog={
        x=x,
        y=y,
        width=w,
        height=h,
        dirty=true,
        scrollPos=1,
        canTakeFocus=true,
        children={},
        visible=false,
    }

    setmetatable(dialog,class_dialog_meta)
    return dialog
  end

end

--list box zone
do
  local class_listbox = { }
  local class_listbox_meta = { __index=class_listbox}
  subclassGuiElement(class_listbox)

  function class_listbox:draw()
    local list=self.list
    for i=1,self.height do
      local index=i+self.scrollPos-1
      local pad,tail=" "," "
      if index==self.selected then
        pad=">"
        tail="<"
        setColors(self.selectedFG,self.selectedBG)
      else
        setColors(self.FG,self.BG)
      end
      term.setCursorPos(self.x,self.y+i-1)
      term.write(padString(pad..(list[index] or "")..tail,self.width))
    end
    self.dirty=false
  end

  function class_listbox:doCursor()
    if self.selected then
      local item=self.list[self.selected]
      setColors(self.selectedFG,self.selectedBG)
      term.setCursorPos(self.x,self.y+self.selected-self.scrollPos)
      term.setCursorBlink(true)
    else
      term.setCursorBlink(false)
    end
  end

  function class_listbox:select(index)
    local prevSel=self.selected
    if index>0 and index<#self.list then
      self.selected=index
      if index~=prevSel then
        self.dirty=true
        if self.selected<self.scrollPos then
          self.scrollPos=self.selected
        elseif self.selected>self.scrollPos+self.height-1 then
          self.scrollPos=self.selected-self.height+1
        end
        self:doHandler("onSelect",self.selected,self.list[self.selected])
      end
    end
  end

  function class_listbox:getSelectedText()
    return self.list and self.list[self.selected]
  end

  function class_listbox:handleEvent(event)
    local handled=false
    local prevSel=self.selected
    if event[1]=="key" then
      if event[2]==keys.down then
        handled=true
        if not self.selected then
          self:select(1)
        else
          self:select(math.min(#self.list,self.selected+1))
        end
      elseif event[2]==keys.up then
        handled=true
        if not self.selected then
          self:select(1)
        else
          self:select(math.max(1,self.selected-1))
        end
      elseif event[2]==keys.enter then
        self:doHandler("onActivate",self.selected,self.list[self.selected])
      end

    elseif event[1]=="mouse_scroll" then
      self.scrollPos=math.max(1,math.min(#self.list-self.height+1,self.scrollPos+event[2]))
      self.dirty=true
      handled=true
    elseif event[1]=="mouse_click" then
      local clickIndex=event[4]-self.y+self.scrollPos
      if clickIndex==self.selected then
        self:doHandler("onActivate",self.selected,self.list[self.selected])
      else
        self:select(clickIndex)
      end
      handled=true
    end
    return handled
  end

  function newListbox(x,y,w,h,list)
    local listbox={
        x=x,
        y=y,
        width=w,
        height=h,
        list=list,
        selected=nil,
        dirty=true,
        scrollPos=1,
        canTakeFocus=true,
        visible=true,
    }
    setmetatable(listbox,class_listbox_meta)
    return listbox
  end
end


function filePicker(dir, filename, ext, load, heading)
  dir=dir or ""
  filename=filename or "untitled"
  ext=ext or ""
  local buttonText

  if load then
    if not heading then
      heading="Open file..."
    end
    buttonText="Open"
  else
    if not heading then
      heading="Save as..."
    end
    buttonText="Save"
  end

  local termW,termH=term.getSize()
  local myW,myH=26,13
  local myX,myY=math.floor((termW-myW)/2)+1, math.floor((termH-myH)/2)+1
  setColors(colors.black,colors.white)


  local list=fs.list(dir)

  local dialog=newDialog(myX,myY,myW,myH)

  dialog:addElement(newVLine(myX, myY, myH, colors.white))
  dialog:addElement(newVLine(myX+myW-1,myY,myH,colors.white))
  dialog:addElement(newHLine(myX,myY+myH-1,myW,colors.white))
  local fileList=newListbox(myX+1,myY+2,myW-2,9,list)
  local okButton=newButton(myX+myW-7, myY+myH-1, 6, buttonText, true)
  local cancelButton=newButton(myX+myW-16, myY+myH-1, 8, "Cancel", true)

  local titleLabel=newLabel(myX,myY,myW," "..heading,"right",true)
  local dirLabel=newLabel(myX,myY+1,myW," dir:"..dir.."/","right",true)
  local fileField=newTextField(myX+7,myY+11,myW-8)
  fileField:setText(filename)


  dialog:addElement(titleLabel)
  dialog:addElement(dirLabel)
  dialog:addElement(newLabel(myX,myY+11,6," file:","right",true))

  dialog:addElement(fileList)
  dialog:addElement(fileField)
  dialog:addElement(cancelButton)
  dialog:addElement(okButton)

  fileList.onActivate=function(listbox, index, text)
      --todo: check if dir, rebuild list if needed
      --else
        fileField:setText(text)
    end

  local result=nil
  okButton.onClick=function()
      result=fileField.text
      dialog:hide()
    end
  cancelButton.onClick=function()
      result=false
      dialog:hide()
    end

  dialog:giveFocus()

  setColors(colors.white,colors.black)
  dialog:runModal()
  setColors(colors.white,colors.black)
  print()
  term.clear()
end

if shell then
  print("Running from shell")
  os.unloadAPI(guiutils)
  os.loadAPI("guiutils")

  setColors(colors.white,colors.black)
  term.clear()

  if guiutils then
    guiutils.filePicker()
  else
    print("not loaded?")
  end
else
  print("loaded as api")
end

