

local function setColors(nakedFG,nakedBG)
  term.setTextColor(nakedFG)
  term.setBackgroundColor(nakedBG)
end

function padString(str,width,side)
  side=side and side:lower() or "left"
  if #str>width then
    --trim instead
    if side=="center" then
      local trim=(#str-width)/2
      str=str:sub(math.floor(trim)+1,#str-math.ceil(trim))
    elseif side=="right" then
      str=str:sub(#str-width+1)
    else
      str=str:sub(1,width)
    end
    return str
  end

  if side=="center" then
    local pad=(width-#str)/2
    str=(" "):rep(math.ceil(pad))..str..(" "):rep(math.floor(pad))
  elseif side=="right" then
    str=(" "):rep(width-#str)..str
  else
    str=str..(" "):rep(width-#str)
  end
  return str
end

local basicStyle = {
    --defaults
    --  naked is for, in one sense, non-gui elements - interiors of text
    -- fields and list boxes, in general the natural "client area" color.
    nakedFG=colors.white,
    nakedBG=colors.black,
    -- gui color is for gui elements like buttons, window borders, etc. in their
    -- natural (non-selected) state.
    guiFG=colors.black,
    guiBG=colors.white,
    -- selected is used for dual purposes, focused gui elements, like buttons
    --  which have focus, and user selection, such as the selected item in a list,
    --  or block-selected text in an input field/box
    selectedFG=colors.white,
    selectedBG=colors.black,

    -- inactive is used for focusable naked text when unfocused - i.e., text fields
    inactiveFG=colors.white,
    inactiveBG=colors.black,

    --framing characters, added to focused elements in this style
    frameL="[",
    frameR="]",
}

local advStyle = {

    nakedFG=colors.white,
    nakedBG=colors.black,

    guiFG=colors.white,
    guiBG=colors.gray,

    selectedFG=colors.white,
    selectedBG=colors.blue,

    inactiveFG=colors.lightGray,
    inactiveBG=colors.black,

    frameL="",
    frameR="",
}

function applyStyle(obj,style)
  for k,v in pairs(style) do
    obj[k]=v
  end
end

function applyDefaultStyle(obj)
  applyStyle(obj,term.isColor() and advStyle or basicStyle)
end

--base gui zone
do
  local class_guielement = {
    }
  local class_guielement_meta = { __index=class_guielement }

  function class_guielement:isDirty()
    return self.dirty
  end

  function class_guielement:handleEvent(e)
  end

  function class_guielement:giveFocus()
    if self.canTakeFocus then
      self.hasFocus=true
      self.dirty=true
      return true
    end
  end

  function class_guielement:loseFocus()
    if self.hasFocus then
      self.hasFocus=false
      self.dirty=true
    end
  end

  function class_guielement:show()
    if not self.visible then
      self.visible=true
      self.dirty=true
    end
  end

  function class_guielement:hide()
    if self.visible then
      self.visible=false
    end
  end

  function class_guielement:doCursor()
    term.setCursorBlink(false)
  end

  function class_guielement:doHandler(name,...)
    local h=self[name]
    if type(h)=="function" then
      h(self,...)
    end
    --todo: implement event style handlers later
  end

  function subclassGuiElement(class)
    if class~=class_guimetatable then
      setmetatable(class,class_guielement_meta)
    end
  end

end

--label zone
do
  local class_label = {

    }
  local class_label_meta = { __index=class_label }
  subclassGuiElement(class_label)

  function class_label:draw()
    if self.naked then
      setColors(self.nakedFG,self.nakedBG)
    else
      setColors(self.guiFG,self.guiBG)
    end
    term.setCursorPos(self.x,self.y)
    term.write(padString(self.text,self.width,self.textAlign))
    self.dirty=false
  end

  function class_label:setText(text)
    self.text=text
    self.dirty=true
  end


  function newLabel(x,y,w,text,textAlign,naked)
    if type(textAlign)=="string" then
      textAlign=textAlign:lower()
    end
    if textAlign~="left" and textAlign~="right" and textAlign~="center" then
      textAlign="left"
    end
    local label={
        x=x,
        y=y,
        width=w,
        height=1,
        naked=naked,
        text=text or "label",
        dirty=true,
        textAlign=textAlign,
        visible=true,
      }
    applyDefaultStyle(label)
    setmetatable(label,class_label_meta)
    return label
  end
end

--hline
do
  local class_hline = { }
  local class_hline_meta = { __index=class_hline }
  subclassGuiElement(class_hline)

  function class_hline:draw()
    setColors(self.guiFG,self.guiBG)
    term.setCursorPos(self.x,self.y)
    term.write((" "):rep(self.width))
    self.dirty=false
  end

  function newHLine(x,y,w,color)
    local line={
        x=x,
        y=y,
        width=w,
        height=1,
        nakedBG=color,
        dirty=true,
        visible=true,
      }
    applyDefaultStyle(line)
    setmetatable(line,class_hline_meta)
    return line
  end
end


--vline
do
  local class_vline = { }
  local class_vline_meta = { __index=class_vline }
  subclassGuiElement(class_vline)

  function class_vline:draw()
    setColors(self.guiFG,self.guiBG)
    for y=self.y,self.y+self.height-1 do
      term.setCursorPos(self.x,y)
      term.write((" "):rep(self.width))
    end
    self.dirty=false
  end

  function newVLine(x,y,h,color)
    local line={
        x=x,
        y=y,
        width=1,
        height=h,
        nakedBG=color,
        dirty=true,
        visible=true,
      }
    setmetatable(line,class_vline_meta)
    applyDefaultStyle(line)
    return line
  end
end


--button zone
do
  local class_button = { }
  local class_button_meta = { __index=class_button }
  subclassGuiElement(class_button)

  function class_button:draw()
    term.setCursorPos(self.x,self.y)
    if self.hasFocus then
      setColors(self.selectedFG,self.selectedBG)
    elseif self.naked then
      setColors(self.nakedFG,self.nakedBG)
    else
      setColors(self.guiFG,self.guiBG)
    end

    term.write(self.frameL..padString(self.text,self.width-#self.frameL-#self.frameR,"center")..self.frameR)
  end

  function class_button:doCursor()
    setColors(self.selectedFG,self.selectedBG)
    term.setCursorPos(self.x+1,self.y)
    term.setCursorBlink(true)
  end

  function class_button:handleEvent(e)
    if e[1]=="key" then
      if e[2]==keys.enter then
        self:doHandler("onClick",e[2],e[3],e[4])
        handled=true
      end
    elseif e[1]=="mouse_click" then
      if e[2]==1 then
        self:doHandler("onClick",e[2],e[3],e[4])
        handled=true
      end
    end
  end

  function newButton(x,y,w,text,naked)
    local button={
        x=x,
        y=y,
        width=w,
        height=1,
        naked=naked,
        text=text or "button",
        dirty=true,
        canTakeFocus=true,
        visible=true,
      }
    setmetatable(button,class_button_meta)
    applyDefaultStyle(button)
    return button
  end
end

--text field zone
--dialog zone
do
  local class_textfield = { }
  local class_textfield_meta = { __index=class_textfield }
  subclassGuiElement(class_textfield)

  function class_textfield:draw()
    term.setCursorPos(self.x,self.y)
    local padL,padR=self.frameL,self.frameR
    if self.hasFocus then
      setColors(self.nakedFG,self.nakedBG)
    else
      padL,padR=(" "):rep(#padL),(" "):rep(#padR)
      setColors(self.inactiveFG, self.inactiveBG)
    end

    local visStr=self.text:sub(self.scrollPos)

    term.write(padL..padString(visStr,self.width-#self.frameL-#self.frameR)..padR)
  end

  function class_textfield:doCursor()
    setColors(self.nakedFG,self.nakedBG)
    term.setCursorPos(self.x+self.cursorPos-self.scrollPos+#self.frameL,self.y)
    term.setCursorBlink(true)
  end

  function class_textfield:handleEvent(e)
    local handled=false
    local prevCurPos=self.cursorPos
    if e[1]=="key" then
      if e[2]==keys.left then
        self.cursorPos=math.max(1,self.cursorPos-1)
        handled=true
      elseif e[2]==keys.right then
        self.cursorPos=math.min(#self.text+1,self.cursorPos+1)
        handled=true
      elseif e[2]==keys.home then
        self.cursorPos=1
        handled=true
      elseif e[2]==keys["end"] then
        self.cursorPos=#self.text+1
        handled=true
      elseif e[2]==keys.backspace then
        self.text=self.text:sub(1,self.cursorPos-2)..self.text:sub(self.cursorPos)
        self.cursorPos=math.max(1,self.cursorPos-1)
        self.dirty=true
        handled=true
      elseif e[2]==keys.delete then
        label=label:sub(1,self.cursorPos-1)..label:sub(self.cursorPos+1)
        self.dirty=true
        handled=true
      end
    elseif e[1]=="char" then
      --insert to text
      self.text=self.text:sub(1,self.cursorPos-1)..e[2]..self.text:sub(self.cursorPos)
      self.cursorPos=self.cursorPos+1
      self.dirty=true

      handled=true
    elseif e[1]=="mouse_click" and e[2]==1 then
      self.cursorPos=math.min(#self.text+1,e[3]-self.x+self.scrollPos-#self.frameL)
      handled=true
    elseif e[1]=="mouse_scroll" then
      self.cursorPos=math.max(1,math.min(#self.text-self.scrollPos+2,self.cursorPos+e[2]))
      handled=true
    end

    if prevCurPos~=self.cursorPos then
      if self.cursorPos<self.scrollPos+3 then
        self.scrollPos=math.max(1,self.cursorPos-3)
        self.dirty=true
      elseif self.cursorPos>=self.scrollPos+self.width-1-#self.frameL-#self.frameR then
        self.scrollPos=self.cursorPos-self.width+1+#self.frameL+#self.frameR
        self.dirty=true
      end
    end

    return handled
  end

  function class_textfield:setText(text)
    self.text=text
    self.cursorPos=#text+1
    self.scrollPos=math.max(1,#text-self.width)
    self.dirty=true
  end

  function newTextField(x,y,w)
    local field={
        x=x,
        y=y,
        width=w,
        height=1,
        text="",
        dirty=true,
        canTakeFocus=true,
        cursorPos=1,
        scrollPos=1,
        visible=true,
      }

    setmetatable(field,class_textfield_meta)
    applyDefaultStyle(field)
    return field
  end

end

--dialog zone
do
  local class_dialog = { }
  local class_dialog_meta = { __index=class_dialog }
  subclassGuiElement(class_dialog)

  function class_dialog:draw()
    for i=1,#self.children do
      if self.children[i].dirty then
        self.children[i]:draw()
      end
    end
    self.dirty=false
  end

  function class_dialog:redraw()
    for i=1,#self.children do
      if self.children[i].visible then
        self.children[i]:draw()
      end
    end
    self.dirty=false
  end

  function class_dialog:isDirty()
    if self.dirty then
      return true
    end
    for i=1,#self.children do
      if self.children[i].dirty then
        return true
      end
    end
  end


  function class_dialog:doCursor()
    if self.hasFocus and self.focusChild then
      self.children[self.focusChild]:doCursor()
    else
      term.setCursorBlink(false)
    end
  end

  function class_dialog:handleEvent(event)
    local handled=false
    if event[1]:sub(1,6)=="mouse_" then
      local mx,my=event[3],event[4]
      for i=1,#self.children do
        local child=self.children[i]
        if mx>=child.x and mx<child.x+child.width and
           my>=child.y and my<child.y+child.height then
          if self.focusChild~=i and child.canTakeFocus then
            self.children[self.focusChild]:loseFocus()
            self.focusChild=i
            child:giveFocus()
          end
          if child:handleEvent(event) then
            handled=true
            break
          end
        end
      end
    elseif event[1]=="key" or event[1]=="char" then
      if event[2]==keys.leftCtrl then
        --focus to my menu?
        --handled=true
      elseif event[2]==keys.tab then
        --give focused child a chance
        if self.focusChild then
          handled=self.children[self.focusChild]:handleEvent(event)
        end
        if not handled and self.focusChild then
          self.children[self.focusChild]:loseFocus()
          repeat
            self.focusChild=self.focusChild%#self.children+1
          until self.children[self.focusChild]:giveFocus()
          handled=true
        end
      elseif self.focusChild then
        handled=self.children[self.focusChild]:handleEvent(event)
      end
    else
      --anything not key or mouse related, give 'em all a stab at
      for i=1,#self.children do
        if self.children[i]:handleEvent(event) then
          break
        end
      end
    end
    return handled
  end

  function class_dialog:addElement(child)
    self.children[#self.children+1]=child
    if self.focusChild==nil and child.canTakeFocus then
      self.focusChild=#self.children
      child:giveFocus()
      child.parent=self
    end
  end

  function class_dialog:giveFocus()
    self.hasFocus=true
    self.dirty=true
    if self.focusChild==nil then
      self.focusChild=0
      repeat
        self.focusChild=self.focusChild+1
      until self.focusChild>#self.children or self.children[self.focusChild]:giveFocus()
      if self.focusChild>#self.children then
        self.focusChild=nil
      end
    end
  end

  function class_dialog:show()
    if not self.visible then
      self.visible=true
      self.dirty=true
      for i=1,#self.children do
        if self.children[i].visible then
          self.children[i].dirty=true
        end
      end
    end
  end

  function class_dialog:runModal()
    self:show()
    self:giveFocus()
    while self.visible do
      if self:isDirty() then
        self:draw()
      end
      self:doCursor()
      local e={os.pullEvent()}
      self:handleEvent(e)
    end
    self:hide()
  end

  function newDialog(x,y,w,h)
    local dialog={
        x=x,
        y=y,
        width=w,
        height=h,
        dirty=true,
        scrollPos=1,
        canTakeFocus=true,
        children={},
        visible=false,
    }

    setmetatable(dialog,class_dialog_meta)
    applyDefaultStyle(dialog)
    return dialog
  end

end

--list box zone
do
  local class_listbox = { }
  local class_listbox_meta = { __index=class_listbox}
  subclassGuiElement(class_listbox)

  function class_listbox:draw()
    local list=self.list
    for i=1,self.height do
      local index=i+self.scrollPos-1
      local head,tail=(" "):rep(#self.frameL),(" "):rep(#self.frameR)

      if index==self.selected then
        head,tail=self.frameL,self.frameR
        setColors(self.selectedFG,self.selectedBG)
      else
        setColors(self.nakedFG,self.nakedBG)
      end
      term.setCursorPos(self.x,self.y+i-1)
      term.write(padString(head..(list[index] or "")..tail,self.width))
    end
    self.dirty=false
  end

  function class_listbox:doCursor()
    if self.selected then
      local item=self.list[self.selected]
      setColors(self.selectedFG,self.selectedBG)
      term.setCursorPos(self.x,self.y+self.selected-self.scrollPos)
      term.setCursorBlink(true)
    else
      term.setCursorBlink(false)
    end
  end

  function class_listbox:select(index)
    local prevSel=self.selected
    if index>0 and index<=#self.list then
      self.selected=index
      if index~=prevSel then
        self.dirty=true
        if self.selected<self.scrollPos then
          self.scrollPos=self.selected
        elseif self.selected>self.scrollPos+self.height-1 then
          self.scrollPos=self.selected-self.height+1
        end
        self:doHandler("onSelect",self.selected,self.list[self.selected])
      end
    end
  end

  function class_listbox:getSelectedText()
    return self.list and self.list[self.selected]
  end

  function class_listbox:handleEvent(event)
    local handled=false
    local prevSel=self.selected
    if event[1]=="key" then
      if event[2]==keys.down then
        handled=true
        if not self.selected then
          self:select(1)
        else
          self:select(math.min(#self.list,self.selected+1))
        end
      elseif event[2]==keys.up then
        handled=true
        if not self.selected then
          self:select(1)
        else
          self:select(math.max(1,self.selected-1))
        end
      elseif event[2]==keys.enter then
        self:doHandler("onActivate",self.selected,self.list[self.selected])
      end

    elseif event[1]=="mouse_scroll" then
      self.scrollPos=math.max(1,math.min(#self.list-self.height+1,self.scrollPos+event[2]))
      self.dirty=true
      handled=true
    elseif event[1]=="mouse_click" then
      local clickIndex=event[4]-self.y+self.scrollPos
      if clickIndex==self.selected then
        self:doHandler("onActivate",self.selected,self.list[self.selected])
      else
        self:select(clickIndex)
      end
      handled=true
    end
    return handled
  end

  function newListbox(x,y,w,h,list)
    local listbox={
        x=x,
        y=y,
        width=w,
        height=h,
        list=list or {},
        selected=nil,
        dirty=true,
        scrollPos=1,
        canTakeFocus=true,
        visible=true,
    }
    setmetatable(listbox,class_listbox_meta)
    applyDefaultStyle(listbox)
    return listbox
  end
end

function getCenteredPos(w,h)
  local termW,termH=term.getSize()
  local x,y=math.floor((termW-w)/2)+1, math.floor((termH-h)/2)+1

  return x,y
end

function messageBox(title,text,width,buttonLabels)
  buttonLabels=buttonLabels or {"Ok"}

  local lines={}
  for word in text:gmatch("%S+") do
    if #lines==0 or #lines[#lines]+1+#word>width-2 then
      lines[#lines+1]=word
    else
      lines[#lines]=lines[#lines].." "..word
    end
  end

  local height=#lines+2

  local x,y=getCenteredPos(width,height)

  local dialog=newDialog(x,y,width,height)
  dialog:addElement(newHLine(x,y,width))
  dialog:addElement(newHLine(x,y+height-1,width))
  dialog:addElement(newVLine(x,y,height))
  dialog:addElement(newVLine(x+width-1,y,height))
  dialog:addElement(newLabel(x+2,y,width-4,title))
  for i=1,#lines do
    dialog:addElement(newLabel(x+1,y+i,width-2,lines[i],"left",true))
  end

  local choice=0

  do
    right=x+width-1
    for i=1,#buttonLabels do
      local button=newButton(right-#buttonLabels[i]-3,y+height-1,#buttonLabels[i]+2,buttonLabels[i])
      right=button.x
      button.onClick=function() choice=i dialog:hide() end
      dialog:addElement(button)
    end
  end

  dialog:runModal()
  return choice
end

function confirmDialog(title,text,width)
  return messageBox(title,text,width,{"Ok","Cancel"})==1
end


function filePicker(dir, filename, ext, save, heading)
  dir=dir or "/"
  if not dir:match("/$") then
    dir=dir.."/"
  end
  filename=filename or "untitled"
  ext=ext or ""

  local buttonText

  if not save then
    if not heading then
      heading="Open file..."
    end
    buttonText="Open"
  else
    if not heading then
      heading="Save as..."
    end
    buttonText="Save"
  end

  local myW,myH=26,13
  local myX,myY=getCenteredPos(myW,myH)

  local dialog=newDialog(myX,myY,myW,myH)

  dialog:addElement(newVLine(myX, myY, myH, colors.white))
  dialog:addElement(newVLine(myX+myW-1,myY,myH,colors.white))
  dialog:addElement(newHLine(myX,myY+myH-1,myW,colors.white))
  local fileList=newListbox(myX+1,myY+2,myW-2,9)
  local okButton=newButton(myX+myW-7, myY+myH-1, 6, buttonText)
  local cancelButton=newButton(myX+myW-16, myY+myH-1, 8, "Cancel")

  local titleLabel=newLabel(myX+1,myY,myW-2,heading)
  local dirLabel=newLabel(myX+1,myY+1,myW-2,"dir:"..dir)
  local fileField=newTextField(myX+6,myY+11,myW-8)
  fileField:setText(filename)


  dialog:addElement(titleLabel)
  dialog:addElement(dirLabel)
  dialog:addElement(newLabel(myX+1,myY+11,5,"file:"))

  dialog:addElement(fileList)
  dialog:addElement(fileField)
  dialog:addElement(cancelButton)
  dialog:addElement(okButton)

  local function buildFileList(dir)
    dirLabel:setText(" dir:"..dir)
    local list=fs.list(dir)
    table.sort(list,function(a,b)
        local aDir,bDir=fs.isDir(dir..a),fs.isDir(dir..b)
        if aDir == bDir then
          return a<b
        else
          return aDir
        end
      end)
    local i=1
    while list[i] and fs.isDir(dir..list[i]) do
      list[i]=list[i].."/"
      i=i+1
    end
    if dir~="/" then
      table.insert(list,1,"..")
    end
    fileList.list=list
    fileList.curPos=1
    fileList.selected=nil
    fileList.dirty=true
  end
  buildFileList(dir)

  fileList.onActivate=function(listbox, index, text)
      if fs.isDir(dir..text) then
        dir="/"..fs.combine(dir,text)
        if not dir:match("/$") then
          dir=dir.."/"
        end
        buildFileList(dir)
      else
        fileField:setText(text)
      end
    end

  local result=nil
  okButton.onClick=function()
      local cancel=false
      local path=dir..fileField.text
      if save then
        if fs.isReadOnly(path) then
          messageBox("Error!","Target file path is read-only!",20)
          cancel=true
        elseif fs.exists(dir..fileField.text) then
          cancel=not confirmDialog("Overwrite?","File already exists, overwrite?",20)
        end
      else
        if not fs.exists(dir..fileField.text) then
          cancel=not confirmDialog("New File?","Specified file doesn't exist! Create it?",20)
        end
      end

      if not cancel then
        result={dir,fileField.text}
        dialog:hide()
      else
        dialog:redraw()
      end
    end
  cancelButton.onClick=function()
      dialog:hide()
    end

  dialog:giveFocus()

  dialog:runModal()

  return unpack(result or {})
end

if shell then
  print("Running from shell")
  os.unloadAPI(guiutils)
  os.loadAPI("guiutils")


  if guiutils then
    local _c=term.isColour
    --[[
    term.isColour=function() return false end
    term.isColor=term.isColour
    --]]
    setColors(colors.white,colors.black)
    term.clear()
    local result=guiutils.filePicker("/","untitled",nil,true)
    setColors(colors.white,colors.black)
    print()
    term.clear()
    print("Result: "..tostring(result))
    term.isColour=_c
    term.isColor=_c
  else
    print("not loaded?")
  end
else
  print("loaded as api")
end

