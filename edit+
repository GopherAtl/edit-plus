--[===============================================]

--edit+

local programDir=shell.getRunningProgram():match("^(.-/?)[^/]+$")

local settings = {
  recentFiles = { },
  syntaxStyle = "pastebin",
}


function grabFile(branch,name,load)
  write("downloading '"..name.."'...")

  local req=http.get("https://raw.githubusercontent.com/GopherAtl/edit-plus/"..branch.."/"..name)
  if req==nil then
    error("Cound't make request!")
  end

  if req.getResponseCode()~=200 then
    req.close()
    error("Unexpected response code "..req.getResponseCode())
  end

  local text=req.readAll()

  req.close()


  local file=fs.open(programDir..name,"w")
  if not file then
    error("Couldn't open file '"..name.."' for writing!")
  end

  file.write(text)
  file.close()
  print("success! "..#text.." bytes")
  if load then
    os.loadAPI(programDir..name)
  end
end



local function loadAPI(name)
  --if this is a first run after update, force reload all apis
  if settings.freshUpdate then
    _G[name]=nil
  end
  if not _G[name] then
    --search for it
    local searchPaths={"/",shell.dir().."/","apis/",programDir,"/usr/lib/","/lib/"}
    for i=1,#searchPaths do

      if searchPaths[i]==nil then
        print(shell.getRunningProgram())
        print(shell.getRunningProgram():match("^(.-/)%w+$"))
      end
      if fs.exists(searchPaths[i]..name) then
        os.loadAPI(searchPaths[i]..name)
        break
      end
    end
    if not _G[name] then
      error("Couldn't find "..name.." api!")
    end
  end
end



local settingsPath

local function loadSettings()
  local file=fs.open(settingsPath,"r")
  if not file then
    error("Couldn't open settings file to read!")
  end
  local text=file.readAll()
  file.close()
  local t=textutils.unserialize(text)
  --copy fields over, so defaults for new settings don't break things when new features added
  for k,v in pairs(t) do
    settings[k]=v
  end
end


local function saveSettings()
  local file=fs.open(settingsPath,"w")
  if not file then
    guiutils.messageBox("Error!","Couldn't open settings file to write!")
  else
    file.write(textutils.serialize(settings))
    file.close()
  end
end

--load saved config settings
if fs.exists(".edit+") then
  settingsPath=".edit+"
  loadSettings()
elseif fs.exists("/etc") and fs.isDir("/etc") then
  settingsPath="/etc/.edit+"
  if fs.exists("/etc/.edit+") then
    loadSettings()
  else
    --create file with defaults
    saveSettings()
  end
else
  settingsPath=programDir..".edit+"
  if fs.exists(settingsPath) then
    loadSettings()
  else
    saveSettings()
  end
end



local args={...}


if #args<1 then
  print[[
  usage:
edit+ <filename>
edit+ --update
edit+ --update beta]]
return
end

if args[1]=="--update" then
  local branch="master"
  --update mahself!
  if args[2] then
    if args[2]=="beta" then
      branch="dev"
    else
      print("unrecognized 2nd arg to --update.")
      return
    end
  end
  print("updating files...")
  local path=shell.dir().."/"

  local filelist
  do
    local req=http.get("https://raw.githubusercontent.com/GopherAtl/edit-plus/"..branch.."/filelist.txt")
    filelist=req.readAll()
    req.close()
  end

  for ftype,fname in filelist:gmatch("(%w+):([%w%+]+)") do
    grabFile(branch,fname)
  end
  --note this in the settings, we'll force-reload the APIs
  settings.freshUpdate=true
  settings.branch=branch
  saveSettings()
  return
end

loadAPI("hilight")
loadAPI("document")
loadAPI("guiutils")
settings.freshUpdate=nil


local filename=args[1]

local filePath=shell.dir().."/"..filename

local activeDoc = document.new(filePath)


term.clear()

local running=true
local w,h=term.getSize()

local lastClickPos={x=1,y=1}
local clipboard

local viewRect
local mainMenu, advancedMenu, contextMenu, activeMenu

local guiElements = {}
local activeGuiElement=0

local drawMenu

local blockSelecting=false

local function updateViewRect()
  w,h=term.getSize()
  viewRect={
      x=1,
      y=1,
      w=w,
      h=settings.hideMenus and h or (h-1),
    }
  activeDoc:updateViewRect(viewRect)
end

updateViewRect()

local function redrawMenus()
  activeMenu.dirty=true
  for i=1,#guiElements do
    if guiElements[i].dirty then
      guiElements[i]:draw()
    end
  end
end

local function redrawLine(screenLine)
  activeDoc:redrawLine(screenLine)

  if screenLine==h then
    activeMenu:draw()
  end
end


local function drawLineNum()

  local lineNum=" "..activeDoc:getTextY().." "
  term.setCursorPos(viewRect.w-#lineNum+1,h)
  term.setBackgroundColor(colors.white)
  term.setTextColor(colors.black)
  term.write(lineNum)
  term.setBackgroundColor(colors.black)
  term.setTextColor(colors.white)
end





local function curTextPos()
  local textPos=activeDoc:getTextPos()
  return textPos.y,textPos.x
end


local function doCursor()
  if settings.advancedMenus and advancedMenu.visible then
    term.setCursorPos(2,h)
  else
    term.setCursorPos(activeDoc:trueCurPos())
  end
  term.setTextColor(colors.white)
  term.setCursorBlink(true)
end




local function gotoLine(lineNum)
  activeDoc:setTextPos(1,lineNum)
end


local function save()
  redrawMenus()
  activeDoc:save()
end

local function saveAs()
  redrawMenus()
  activeDoc:saveAs()
end

local function load()
  activeDoc:redrawDirty()
  redrawMenus()
  activeDoc:load()
end

local function new()
  --TODO: file dialog
  --actually, just make new, with filename nil'd, and do
  --file dialog on save if filename is nil.
  --will facilitate saveAs also.
end

   local helpPages={[[
Basic Menu:

Hotkeys for menu items
are in yellow, press to
select.
Ctrl closes the current
menu, arrows navigate,
enter selects.

special keys:

b - begin/end block
selection

tab - decrease indent on
selected line/block

    tab for next page
      ctrl to exit]], [[
Advanced Menu:

q - quit/exit
s - save file
r - run program
< or tab - decrease indent
> - increase indent
c - copy
x - cut
v - paste
b - toggle block sel
? - help (this)
h - toggle menu hiding
m - switch to basic menu



    tab for next page
      ctrl to exit]],}

local function help()
  term.setTextColor(colors.white)
  term.setBackgroundColor(colors.black)

  local pageNum=settings.advancedMenus and 2 or 1
  local redraw=true

  while true do
    if redraw then
      term.clear()
      term.setCursorPos(1,1)
      write(helpPages[pageNum])
      redraw=false
    end

    local e={os.pullEvent()}
    if e[1]=="key" then
      if e[2]==keys.tab then
        pageNum=pageNum%#helpPages+1
        redraw=true
      elseif e[2]==keys.leftCtrl then
        break
      end
    end
  end

  activeDoc:dirtyAll()
end

local charKeys={[57]=' ', [43]='\\', [83]='.', [2]='1', [3]='2', [4]='3', [5]='4', [6]='5', [7]='6', [8]='7', [9]='8', [10]='9', [11]='0', [12]='-', [13]='=', [51]=',', [52]='.', [53]='/', [181]='/', [55]='*', [26]='[', [27]=']', [71]='7', [72]='8', [73]='9', [74]='-', [75]='4', [76]='5', [77]='6', [78]='+', [79]='1', [80]='2', [81]='3', [39]=';', [40]='"', [41]='`', [82]='0', [30]='a', [48]='b', [46]='c', [32]='d', [18]='e', [33]='f', [34]='g', [35]='h', [23]='i', [36]='j', [37]='k', [38]='l', [50]='m', [49]='n', [24]='o', [25]='p', [16]='q', [19]='r', [31]='s', [20]='t', [22]='u', [47]='v', [17]='w', [45]='x', [21]='y', [44]='z', }

local runEnv={shell=shell, multishell=multishell}
setmetatable(runEnv,{__index=_G})

local function run()
  --save changes first
  save()
  term.setTextColor(colors.white)
  term.setBackgroundColor(colors.black)
  term.clear()
  term.setCursorPos(1,1)

  local function logWrap(f)
    local log=fs.open("runlog","w")
    local co=coroutine.create(f)
    local filter={coroutine.resume(co)}
    while coroutine.status(co)~="dead" do
      local e={os.pullEventRaw()}
      if e[1]=="terminate" then
        break
      end
      if #filter<2 or filter[2]==e[1] then
        log.write(table.concat(e,",").."\n")
        filter={coroutine.resume(co,unpack(e))}
      end
      if filter[1]==false then
        break
      end
    end
    log.close()
  end

  local function replayWrap(f)
    local log=io.open("runlog","r")

    local co=coroutine.create(f)
    local filter={coroutine.resume(co)}

    for line in log:lines() do
      local args={}
      line:gsub("[^,]+",function(v) args[#args+1]=v end)
      if args[1]=="key" then
        args[2]=tonumber(args[2])
      elseif args[1]=="mouse_click" or args[2]=="mouse_drag" or args[2]=="mouse_scroll" then
        args[2]=tonumber(args[2])
        args[3]=tonumber(args[3])
        args[4]=tonumber(args[4])
      end
      sleep(.2)
      coroutine.resume(co,unpack(args))
    end
    log:close()
    while coroutine.status(co)~="dead" do
      local e={os.pullEventRaw()}
      if e[1]=="terminate" then
        break
      end
      if #filter<2 or filter[2]==e[1] then
        filter={coroutine.resume(co,unpack(e))}
      end
      if filter[1]==false then
        break
      end
    end
  end

  local succ
  local filePath=activeDoc:getFilePath()
  local func,err=loadfile(filePath)
  if not func then
    succ=false
  else
    setfenv(func,runEnv)
    succ,err=pcall(func)
  end

  term.setTextColor(colors.white)
  term.setBackgroundColor(colors.black)
  if not succ and err then
    print("\nProgram '"..filePath.."' crashed with error:")
    printError(err)
  else
    print("\nprogram exited normally")
  end
  write("press a key to return to editor")
  e={os.pullEvent("key")}
  if charKeys[e[2]] then os.pullEvent() end
  if not succ then
    local lineNum,text=err:match(filename..":(%d+):(.-)")
    if lineNum then
      gotoLine(tonumber(lineNum))
    end
  end
  term.clear()
  activeDoc:dirtyFrom(1)
end




local commands = {
  ["save"] = {
      func=save,
    },
  ["saveAs"] = {
      func=saveAs,
    },
  ["load"] = {
      func=load,
    },
  ["run"] = {
      func=run,
    },
  ["exit"] = {
      func=function() running=false end,
    },

  ["increase indent"] = {
      func=function() activeDoc:increaseIndent() end,
    },
  ["decrease indent"] = {
      func=function() activeDoc:decreaseIndent() end,
    },
  ["beginBlockSelect"] = {
      func=function() activeDoc:toggleBlockSelecting() end,
    },

  ["copy"] = {
      func=function() activeDoc:copy() end,
    },
  ["cut"] = {
      func=function() activeDoc:cut() end,
    },
  ["paste"] = {
      func=function() activeDoc:paste() end,
    },

  ["toggleHideMenu"] = {
      func=function()
        settings.hideMenus=not settings.hideMenus;
        activeMenu.alwaysVisible=not settings.hideMenus
        saveSettings()
        updateViewRect()
        --NEEDED? dirtyLines[h]=true
      end,
    },
  ["toggleAdvancedMenu"] = {
      func=function()
        settings.advancedMenus=not settings.advancedMenus
        saveSettings()
        if settings.advancedMenus then
          advancedMenu.alwaysVisible=not settings.hideMenus
          mainMenu.alwaysVisible=false
          activeMenu=advancedMenu
        else
          mainMenu.alwaysVisible=not settings.hideMenus
          advancedMenu.alwaysVisible=false
          activeMenu=mainMenu
        end
        activeMenu.dirty=true

        updateViewRect()
        --NEEDED? dirtyLines[h]=true
     end,
   },

  ["help"] = {
      func=help,
    },
}

local basicMenuDef={
    horizontal=true,
    {label="&File", type="submenu", submenu={
        {label="&Save", type="command", cmd="save", },
      {label="Save &As...", type="command", cmd="saveAs", },
      {label="&Open...", type="command", cmd="load", },
--      {label="&New", type="command", cmd="new", },
        {label="&Run", type="command", cmd="run", },
        {label="E&xit", type="command", cmd="exit", },
      },
    },

    {label="&Edit", type="submenu", submenu={
        {label="Cut-&x", type="command", cmd="cut", },
        {label="&Copy", type="command", cmd="copy", },
        {label="Paste-&v", type="command", cmd="paste", },
        {label="Inc. Indent-&>", type="command", cmd="increase indent", },
        {label="Dec. Indent-&<", type="command", cmd="decrease indent", },
        {label="&Block select", type="command", cmd="beginBlockSelect", },
      },
    },
--  {label="&Search", type="submenu", submenu={
--      {label="&Find...", type="command", cmd="find", },
--      {label="Find &Next", type="command", cmd="findNext", },
--      {label="Find &Prev", type="command", cmd="findPrev", },
--      {label="&Replace...", type="command", cmd="findReplace", },
  {label="&View", type="submenu", submenu={
--      {label="&Line Numbers", type="command", cmd="toggleLineNums", },
--      {label="&Line Numbers", type="command", cmd="toggleLineNums", },
      {label="&Hide Menu", type="toggle", cmd="toggleHideMenu", test=function() return settings.hideMenus end},
      {label="&Advanced Menu", type="toggle", cmd="toggleAdvancedMenu", test=function() return settings.advancedMenus end },
    },
  },

  {label="&Help", type="command", cmd="help", },
}

local hotkeys = {
  ["c"]="copy",
  ["x"]="cut",
  ["v"]="paste",
  ["b"]="beginBlockSelect",
  [keys.tab]="decrease indent",
  ["<"]="decrease indent",
  [">"]="increase indent",
  ["q"]="exit",
  ["s"]="save",
  ["r"]="run",
  ["?"]="help",
  ["m"]="toggleAdvancedMenu",
  ["h"]="toggleHideMenu",
  ["a"]="saveAs",
  ["o"]="load",
}

function drawMenuItem_color(item,x,y,width,isSelected)
  term.setCursorPos(x,y)
  term.setBackgroundColor(isSelected and colors.blue or colors.gray)
  --pre
  local w=1
  term.write(" ")
  if item.type=="toggle" then
    term.write("["..(item.test() and "X" or " ").."] ")
    w=w+3
  end
  if #item.pre>0 then
    term.setTextColor(colors.white)
    term.write(item.pre)
    w=w+#item.pre
  end
  term.setTextColor(colors.yellow)
  if item.embedKey then
    term.write(item.hk)
    term.setTextColor(colors.white)
    term.write(item.post)
    w=w+#item.hk+#item.post
    term.write((" "):rep(width-w))
  else
    term.write((" "):rep(width-w-1-#item.hk)..item.hk.." ")
  end
  term.setBackgroundColor(colors.black)
end

function drawMenuItem_basic(item,x,y,width,isSelected)
  term.setCursorPos(x,y)
  term.setBackgroundColor(colors.white)
  term.setTextColor(colors.black)
  local w=1
  term.write(" ")
  if item.type=="toggle" then
    term.write("["..(item.test() and "X" or " ").."] ")
    w=w+3
  end
  if #item.pre>0 then
    term.write(pre)
    w=w+#pre
  end
  if item.embedKey then
    term.write("("..item.hk..")"..item.post)
    w=w+2+#hk+#item.post
    term.write((" "):rep(width-w))
  else
    term.write((" "):rep(width-w-1-#item.hk)..item.hk.." ")
  end
  term.setBackgroundColor(colors.black)
end

local drawMenuItem=term.isColor() and drawMenuItem_color or drawMenuItem_basic

drawMenu =function(menu)
  if menu.visible or menu.alwaysVisible then
    if menu.horizontal then
      local offset=0
      for i=1,#menu do
        if menu.x+offset+menu[i].width - 1 > w then
          break
        end
        menu[i].x=menu.x+offset
        drawMenuItem(menu[i],menu.x+offset,menu.y,menu[i].width,menu.selected==i)
        offset=offset+menu[i].width
      end
      menu.lastX=offset
      term.write((" "):rep(w-offset))
    else
      if menu.y+#menu > h then
        menu.y=h - #menu+1
      end
      if menu.width + menu.x  > w then
        menu.x=w-menu.width
      end
      for i=1,#menu do
        drawMenuItem(menu[i],menu.x,menu.y+i-1,menu.width,menu.selected==i)
      end
    end
    menu.dirty=false
  end
end

local function handleMenuEvent(menu, e)
  local keyNext=menu.horizontal and keys.right or keys.down
  local keyPrev=menu.horizontal and keys.left or keys.up
  local handled=false

  if e[1]=="key" then
    if not menu.childActive then
      handled = true
      if e[2]==keys.leftCtrl or e[2]==keys.rightAlt then
        menu:hide()
      elseif e[2]==keys.enter then
        --do the selected thing
        menu:doThing(menu.selected)
      elseif e[2]==keys.tab then
        menu:doThing("decrease indent")
      end
    end
    if not menu.childActive or menu.horizontal then
      if e[2]==keyNext then
        if menu.childActive then
          menu.childActive:hide()
        end
        menu.selected=menu.selected%#menu+1
        menu.dirty=true
        handled=true
      elseif e[2]==keyPrev then
        if menu.childActive then
          menu.childActive:hide()
        end
        menu.selected=menu.selected==1 and #menu or menu.selected-1
        menu.dirty=true
        handled=true
      end
    end
  elseif not menu.childActive and e[1]=="char" then
    handled = true
    local thing=menu.hkMap[e[2]:lower()]
    if thing then
      menu:doThing(thing)
    elseif e[2]:lower()=="b" then
      menu:doThing("beginBlockSelect")
    end

  elseif e[1]=="mouse_click" then
    local _,btn,clkX,clkY=unpack(e)
    if menu.horizontal and
        clkY==menu.y and clkX<=menu.lastX then
      if menu.childActive then
        menu.childActive:hide()
      end
      for i=menu.firstShown,#menu do
        if menu[i].x+menu[i].width>clkX then
          menu.selected=i
          menu.dirty=true
          handled = true
          if btn==1 then
            menu:doThing()
          end
          break
        end
      end
    elseif not menu.horizontal and
        clkY>=menu.y and clkY<menu.y+#menu and
        clkX>=menu.x and clkX<menu.x+menu.width then
      menu.selected=clkY-menu.y+1
      if btn==1 and menu[menu.selected].type=="command" then
        menu:doThing()
        handled = true
      end
    else
      menu:hide()
    end
  elseif not menu.childActive and e[1]=="paste" then
    insertText(e[2])
    command=nil
    menu:hide()
    handled = true
  end

  return handled
end

local function showMenu(menu)
  if menu.selected==nil then
    menu.selected=1
  end
  menu.dirty=true
  if menu.parent then
    menu.parent.childActive = menu
  end
  if not menu.visible then
    menu.visible=true
  end
end

local function hideMenu(menu,closeAll)
  if menu.visible then
    menu.selected=nil
    menu.dirty=true
    activeDoc:dirtyFrom(menu.y)
    if menu.parent then
      menu.parent.childActive = false
      if closeAll then
        menu.parent:hide(true)
      end
    end
    menu.visible=false
  end
end

local function doThing(menu,thing)
  thing=thing or menu.selected
  local command=""

    if type(thing)=="number" then
      local item=menu[thing]
      if item then
        if item.type=="command" then
          command=item.cmd
        elseif item.type=="submenu" then
          menu:draw()
          command=nil
          item.submenu:show()
        elseif item.type=="toggle" then
          command=item.cmd
        end
      end
    elseif type(thing)=="string" then
      command=thing
    end

    if command then
      if commands[command] then
        commands[command].func()
        menu:hide(true)
      end
    end

end

local function updatePos(menu,x,y)
  local deltaX=x-menu.x
  local deltaY=y-menu.y
  menu.x=x
  menu.y=y
  for i=1,#menu do
    local item=menu[i]
    if item.type=="submenu" then
      item.submenu:updatePos(item.submenu.x+deltaX, item.submenu.y+deltaY)
    end
  end
end


local function buildMenu(menuDef,parent)
  local menu={hkMap={}}
  local id=menuDef.id or (#guiElements+1)
  guiElements[id]=menu
  menuDef.id=id

  menu.x,menu.y=1,h
  menu.parent=parent
  menu.firstShown=1
  menu.draw=drawMenu
  menu.handleEvent=handleMenuEvent
  menu.show = showMenu
  menu.hide = hideMenu
  menu.doThing = doThing
  menu.updatePos = updatePos

  if not menuDef.horizontal and menu.y+#menu>h then
    menu.y=h-#menu+1
  end

  menu.horizontal=menuDef.horizontal
  local longestLabel=0
  local offset=1
  for i=1,#menuDef do
    local menuItem=menuDef[i]
    local item={}
    for k,v in pairs(menuItem) do
      item[k]=v
    end
    local pre,pk,hk,post=menuItem.label:match("^([^&^-]-)(%-?)&(.)([^&]*)")
    item.pre=pre
    item.post=post
    item.hk=hk
    item.embedKey=pk~="-"
    item.x=menuDef.horizontal and offset or menu.x
    local labelLen
    if item.embedKey then
      labelLen=#pre+1+#post
      if not term.isColor() then
        labelLen=labelLen+2
      end
    else
      labelLen=#pre+2
      if not term.isColor() then
        labelLen=labelLen+1
      end
    end
    if menuItem.type=="toggle" then
      labelLen=labelLen+4
    end
    item.width=labelLen+2
    offset=offset+labelLen+2
    longestLabel=math.max(longestLabel,labelLen)
    menu[#menu+1]=item
    menu.hkMap[hk:lower()]=i
    if item.type=="submenu" then
      item.submenu=buildMenu(item.submenu,menu)
      item.submenu.x,item.submenu.y=menu.x+item.width,menu.y+i-1
      if menuDef.horizontal then
        item.submenu.x,item.submenu.y=item.x,menu.y-#item.submenu
      end
    end
  end
  menu.width=longestLabel+2
  return menu
end

advancedMenu={
  draw=function(menu)
      term.setCursorPos(1,h)
      term.setTextColor(colors.white)
      if menu.visible then
        term.write("> ")
        for k,v in pairs(hotkeys) do
          if type(k)=="string" then
            term.write(k)
          end
        end
        term.write("                                             ")
        term.setCursorPos(2,h)
      else
        term.write((" "):rep(w))
      end
      menu.dirty=false

    end,
  handleEvent=function(menu,e)
      if e[1]=="key" or e[1]=="char" then
        if hotkeys[e[2]] then
          commands[hotkeys[e[2]]].func()
          menu:hide()
        elseif e[2]==keys.leftCtrl or e[2]==keys.rightAlt then
          menu:hide()
        end
      end
      return true
    end,
  show=showMenu,
  hide=hideMenu,
  y=h,  x=1,
  horizontal=true,

}


guiElements[#guiElements+1]=advancedMenu
advancedMenu.id=#guiElements

mainMenu=buildMenu(basicMenuDef)
activeDoc:dirtyFrom(1)
term.setCursorBlink(true)

if settings.advancedMenus then
  activeMenu=advancedMenu
else
  activeMenu=mainMenu
end

if not settings.hideMenus then
  activeMenu.alwaysVisible=true
  activeMenu.dirty=true
end

while running do
  term.setTextColor(colors.white)
  term.setBackgroundColor(colors.black)
  activeDoc:redrawDirty()
  redrawMenus()
  drawLineNum()
  doCursor()
  local e={os.pullEvent()}
  local handled=false
  for i=1,#guiElements do
    if guiElements[i].visible and guiElements[i].selected then
      handled=guiElements[i]:handleEvent(e)
      if handled then break end
    end
  end

  if not handled then
    if e[1]=="key" then
      local key=e[2]
      if key==keys.down then
        activeDoc:cursorDown()
      elseif key==keys.up then
        activeDoc:cursorUp()
      elseif key==keys.right then
        activeDoc:cursorRight()
      elseif key==keys.left then
        activeDoc:cursorLeft()
      elseif key==keys.pageDown then
        activeDoc:moveCursor(0,viewRect.h)
      elseif key==keys.pageUp then
        activeDoc:moveCursor(0,-viewRect.h)
      elseif key==keys.leftCtrl then
        activeMenu:show()
      elseif key==keys.enter then
        activeDoc:insertNewline()

      elseif key==keys.backspace then
        activeDoc:backspace()

      elseif key==keys.delete then
        activeDoc:delete()

      elseif key==keys.home then
        activeDoc:setTextX(1)
      elseif key==keys["end"] then
        activeDoc:setTextX(activeDoc:getLineLen()+1)
      elseif key==keys.tab then
        if selectBounds then
          activeDoc:increaseIndent()
        else
          --get the affected line and actual x position in line
          local textPos=activeDoc:getTextPos()
          --insert our char!
          local tab=textPos.x%2==0 and "  " or " "
          activeDoc:insertText(tab)
        end
      end
    elseif e[1]=="char" then
      local char=e[2]
      activeDoc:insertText(e[2])

    elseif e[1]=="mouse_scroll" then
      activeDoc:scrollY(e[2],true)

    elseif e[1]=="mouse_click" then
      if e[2]==1 then
        local x,y=math.min(math.max(e[3],1),w),math.min(math.max(e[4],1),h)
        if y<=viewRect.h then
          activeDoc:setCurPos(x,y)
          lastClickPos={x=x,y=y}
        elseif not settings.advancedMenus and mainMenu.alwaysVisible and not mainMenu.selected then
          if mainMenu:handleEvent(e) then
            mainMenu.visible=true
          end
        end

      elseif e[2]==2 then

      elseif e[2]==3 then

      end
    elseif e[1]=="mouse_drag" then
      activeDoc:dragSelect({x=math.min(math.max(e[3],1),viewRect.w),y=math.min(math.max(e[4],1),viewRect.h)})
    elseif e[1]=="term_resize" then
      updateViewRect()
      activeDoc:dirtyFrom(1)
      mainMenu:updatePos(1,h)
      advancedMenu.y=h
    end
  end
end

term.clear()
term.setCursorPos(1,1)